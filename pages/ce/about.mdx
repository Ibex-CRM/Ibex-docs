# IBEX Chrome Extension

IBEX Chrome Extension was developed for internal use by The Goat Agency employees only.

IBEX Chrome Extension is a tool created to aid with the addition of influencers and their respective channels to our system as well as populating the outreach tab in campaign sheets.

Upon installing the extension and logging in to IBEX, the extension enters a standby mode and waits for the user to visit a social media platform. Upon visiting a profile on any of the supported social media platforms, the following chain of events take place:

1. Request sent to our API to check:

   1. Whether or not the user is logged in to IBEX.

   2. Whether or not that channel is already in the system.

    Visual feedback is provided in the form of a green or red ring around the button indicating the presence of the channel in our system.

2. User is then able to either modify existing information or add new relevant information to the channel. These changes are stored in local storage as they are made.

3. When the user is happy with the information entered into the form, the user can add/update the channel in our system and optionally send that channel to a campaign sheet of their choosing.

4. Upon submission, the extension will ship the current channel off to our backend, which in turn will take care of updating the channel in our database and optionally sending it off to a campaign sheet. Keep in mind that when sending an influencer to a campaign sheet, some delay is to be expected as certain information is added via jobs and these may take some time.

The usecase above is an example of a standard flow of operations that we expect to happen.

---
## Data storage
---

Upon visiting an influencers page on any of the supported platforms, the extension pings the API to check whether or not that specific channel is already in the system or not.

* If the channel **does not exist** in the system, an object is created in local storage that holds all the relevant keys to the information that can be populated using the extension.

* If the channel **does exist** in the system, the relevant channel is retrieved from the API with the information that is currently present in our database and is used to pre-populate the form with existing values.

All changes to a channel are stored locally and therefore will persist through navigating away from the page, browser crashes etc.

In order to clear local storage, navigate to the history tab and select Delete All. Keep in mind that Delete All will delete all channels in local storage ***except for the one you are currently visiting*** and any changes made to channels that have not been uploaded to IBEX ***will be lost***. The reasoning behind that is because objects get created upon the initial visit of the page and removing the existing object from local storage will cause the extension to crash if you were to navigate back to the Upload tab on the extension itself.

During development it is suggested to use the service worker console to see the state of local storage
```javascript
chrome.storage.local.get(console.log)
```
 and to clear local storage
```javascript
chrome.storage.local.clear()
```
followed by a hard refresh of the page you are currently on (if on an influencers page on a supported platform).

---
## Proxy Server - Salty Mesa
---

Salty Mesa is a proxy server set up specifically for the extension to communicate with in order to prevent CORS issues and a very specific Google Chrome bug, which causes the extension to not have an origin header on any outgoing requests, causing issues on different fronts. Previously this was fixed by turning the extension off and back on again post-install, however this was not a viable solution and would break other parts of the extension. As we are unable to fix the underlying cause of these issues, the current workaround was to deploy a proxy server and route all problematic requests through it.

These issues were resolved by modifying an existing CORS-Anywhere repository and running our own version of the proxy. Details to the proxy are outlined in the README of that specific repo.

When running into CORS issues that can not be resolved by any other means (e.g. no access to the endpoint), it is advised to prepend the proxy URL to the link you are trying to fetch (see it in use in background.js). It is also vital to include
```javascript
'x-requested-with': `chrome-extension://${chrome.runtime.id}`
```
as a header to any request that needs to be routed through the proxy, as the proxy operates on a whitelist principle and will block any requests that do not comply with it.

---
## Supported Platforms
---

Currently supported social media platforms are as follows:

* Facebook
* Instagram
* TikTok
* Twitter
* YouTube
* Twitch
* LinkedIn
* Reddit
* Pinterest

This is not an exhaustive list and may be updated in the future according to company needs.

---
## Scripts
---

Scripts folder within the project houses three files, of which mainly you will only be using one.

These scripts are there to build the source code into a usable chrome extension. The scripts are vital and used because of the use of React in the extension.

* ```yarn build``` - will compile the current source code into a build folder, that folder can then be uploaded as an unpacked extension to chrome for testing purposes.

* ```yarn watch``` - essentially the same as build, except it will automatically wait for changes and will compile the build folder automatically.

* BEFORE TRYING TO RELEASE TO CHROME STORE - Make sure you run ```yarn build``` followed by ```zip -r build.zip build``` in order to zip the build folder and prepare it for upload.

---
## Public Folder and its Contents
---

The public folder houses communication with API's along with certain rulesets we have set in place.

* ```background``` - houses all of the API communication for the extension. Due to service worker requests originating from the browser and not the content page you are currently in, most if not all of the API communication needs to take place in the service worker, as the origin of the request will be the visited page when triggered from the content page. This is the main hub for **GET** and **POST** requests.

* ```checkInSystem``` - houses logic to check whether or not the visited channel is in our system or not and act accordingly - when not present, creates a new object in local storage that can be populated, and when present, saves the object straight to local storage as the API is set up to respond with a properly formatted object that does not need any extra modification. This is where we filter out excluded paths as well.

* ```exclusionPaths``` - houses all paths that are excluded from being sent to the API. These are normally help pages, friends lists, event pages etc. **These exclusions are not specific to any platform, it is an umbrella exclusion list and may cause some social media accounts to not show in the extension (e.g. instagram.com/friends will not show as a valid profile, even though it is).** However, in a realistic scenario, this should not cause issues.

* ```constants``` - houses some of the URL paths that we use throughout the extension. This is also where we point the extension to a specific backend, so make sure it is pointed to localhost when working on changes in your local environment. Attempts to have a dynamic environment which would change the path automatically were attempted but were practically not possible given the restrictions that chrome extensions have. ***Remember to change it to staging when testing the extension out on the staging server and to production when uploading the extension to the Chrome Store.***

* ```localStorageApi``` - houses helper functions for saving and retrieving objects from local storage. Remove is not currently used as it struggles with removing nested objects within local storage.

---
## CSS clash and potential iFrame solution
---

Currently our content.css is applied to the entire content page. This means that small side effects occur where the host sites styling gets altered slightly.

The worse example of this was when our CSS caused Twitters infinite scroll to break. It also means that some of the host sites css can affect our extension.

Currently we have fixed the major problems caused on both the host sites and the extension,
however if we find ourselves having more of these issues one fix we have identified is the move all react elements to be displayed within an iFrame.

This original presented some challenges as we had to be able to pass stylesheets into the iframe.

Combining this with Styled Components custom classes meant we needed to include a package (react-frame-component) to achieve this.

The working version of this setup is stored on the branch iframe-test.

---
## Channel Object
---

```javascript
"channel_2_nicocary": {
    "demographics": {
        "age": {
            "dem_13": 4.08,
            "dem_18": 36.54,
            "dem_25": 38.89,
            "dem_35": 13.83,
            "dem_45": 6.52,
            "dem_55": 0,
            "dem_65": 0.14
        },
        "audienceType": "Follower Audience",
        "captured": "2021-09-13T09:42:24.488+00:00",
        "engagementRate": 5.34,
        "gender": {
            "female": 42.7,
            "male": 57.3
        }
    },
    "display_name": "Nico Cary",
    "handle": "nicocary",
    "id": 12126,
    "image": "https://res.cloudinary.com/goatagency/image/upload/v1631290214/qyxvtenbau4seovnm0ly.jpg",
    "in_system": true,
    "influencer": {
        "age_group": "25+",
        "gender": "Male",
        "id": 14212,
        "location": {
            "city": null,
            "country": "United Kingdom",
            "country_code": "GB",
            "created_at": "2019-07-29T11:59:53.271+01:00",
            "google_place_id": "ChIJqZHHQhE7WgIReiWIMkOg-MQ",
            "id": 13,
            "latitude": 55.378051,
            "longitude": -3.435973,
            "name": "gb",
            "options": {},
            "state": null,
            "updated_at": "2020-02-03T15:37:22.237+00:00"
        },
        "nationality": null,
        "type": "influencer"
    },
    "key": "channel_2_nicocary",
    "last_visited": 1631526144738,
    "platform_id": 2,
    "primary_tag": 77,
    "tags": [
        75,
        79,
        81
    ],
    "type": "channel",
    "url": "https://www.instagram.com/nicocary/"
}
```

Originally we had the aim of keeping the channel object as flat as possible when it is pulled into the extension (and stored in Google localStorage).

This lead to  serialising the channel on the server side to have the primary tag and secondary tags directly in the channel object.

However when more options were added to the channel form (nationality, location, age, and gender) we ended up pulling a nested influencer object through with the Channel.

This now means there is some inconsistency in the way we are handling fields that traditionally have sat on the influencer object.

We may look to rewrite this aspect in the future to put the all influencer based fields onto the influencer object.

---
## YouTube Weirdness
---

YouTube has consistently presented challenges due to the way in which it handles unique ID’s, urls, and channel handles.
While all other platforms have a consistant url structure that includes the unique channel handle inside it, YouTube instead opts for 3 very different URL structures.

```Channel URL``` (youtube.com/channel/UCVtFOytbRpEvzLjvqGG5gxQ)

This is the standard URL that YouTube channels use. It contains the unique channel ID.

```Custom URL``` (youtube.com/ksi or youtube.com/c/ksi)

A custom URL is a shorter, easy-to-remember URL.

```Legacy URL``` (youtube.com/user/ksi)
(Note. This user is not the same as the two channels above)

Depending on when a channel was created, it may have a username.

Because of these various URL structures, and the fact that YouTube’s API doesn’t allow for the input of a handle or url to return a channel ID, we are not easily able to extract the Unique ID from all URL’s.
The only way to access the Unique ID is to access the meta tags of the page. However these do not update once the page has loaded originally.
Our solution was to scrape the page through our hosted proxy server every time the Tab updates. This currently works well but may be brittle if youtube makes large changes.

---
## Chrome Extension React and conversion to manifest v3
---

We used the original skeleton outlined by https://github.com/satendra02/react-chrome-extension.

However due to this being built on chrome extension manifest v2 we had to make some changes to make it compatible with v3.

Most of these cheanges are outlined in the Google docs https://developer.chrome.com/docs/extensions/mv3/intro/mv3-migration/.


---
## Woomio Scraper
---

The woomio scraper element of the chrome extension specifically targets the ***Quantify by Woomio*** plugin that the teams use to generate demographics on an influencer. The tool works by targeting the dropdown icon of the plugin and engaging a listener. Once clicked it awaits the data inside and captures the demographics from either the _Engaged Audience_ of _Follower Audience_ tabs. You can switch between them and it will capture the last selected tab.

---
## Places Autocomplete Complexity
---

The Google Places Autocomplete section of the form posed a problem as the API blocks cross origin requests. The API is meant for use from a backend server but as the chrome extension is not a server, it is blocked. These requests are now passed through Salty Mesa to avoid the CORS issues and no significant lag has been recorded. We initially didn't realise this due to a chrome bug that meant the origin was never set on the request and therefore it always worked.

---
## Action Cable
---

Users now have the ability to add influencers into a list live from the chrome extension. There were multiple challenges to get this running consistently. As internal chrome extension connections are limited to 5 minutes, it was difficult to figure out reconnect criteria. Currently works on the logic of querying the CampaignList that influencers are to be added to, saves it to localStorage and reconnects with it whenever the platform or influencer object changes. This was built, but is not currently being used and therefore maintainance for this has been put on a backburner. Will most likely require a review if functionality is seen to be used in the future.

Sonar indicator shows whether the influencer has been Approved/Rejected/Excluded, is already proposed or pending review, or is missing from the campaign list. The user can only add the influencer in if the status is missing, as the status indicator shows influencer approval process live on the extension itself.

Most of the actioncable logic is present in background.js and overlay/index.js.